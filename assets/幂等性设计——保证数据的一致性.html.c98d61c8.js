import{_ as n,o as s,c as e,e as l,a as p,r as i}from"./app.d41ceb81.js";const o={},t=p(`<h1 id="幂等性设计——保证数据的一致性" tabindex="-1"><a class="header-anchor" href="#幂等性设计——保证数据的一致性" aria-hidden="true">#</a> 幂等性设计——保证数据的一致性</h1><p>先看这样一个场景：用户在电商平台购物，看到自己心仪的商品，于是将其加入购物车，之后进入购物车下单结算。这时，由于网络不畅，用户在点击“提交订单” 按钮时卡住了，用户以为没提交成功，就又点击了一次“提交订单”按钮。最终，订单系统给该用户生成了两个订单，其实之前那个订单己经生成成功了。</p><p>这就是一个典型的幂等性问题。由于下单接口没有做好幂等性设计，导致用户进行两次同样的下单操作，系统给用户创建了两个订单。</p><h2 id="什么是幂等性" tabindex="-1"><a class="header-anchor" href="#什么是幂等性" aria-hidden="true">#</a> 什么是幂等性</h2><p>所谓幂等性是指，用户对于同一个操作发起一次请求或多次请求，得到的结果都是一样的，不会因为请求了多次而出现异常现象。</p><p>例如，在支付时，用户点击了两次“立即支付”按钮，发生了重复支付。最终，用户发现被扣了两次款，支付系统也生成了两次支付记录，如下图所示，这就是一点非幂等的场景</p><p><img src="http://dean-imgsubmit.oss-cn-beijing.aliyuncs.com/note/image-20230328205156326.png" alt="image-20230328205156326" loading="lazy"></p><h3 id="需要幂等性的场景" tabindex="-1"><a class="header-anchor" href="#需要幂等性的场景" aria-hidden="true">#</a> 需要幂等性的场景</h3><p>幂等性主要用在重复请求上，有如下几种场景：</p><ul><li>用户多次请求，比如重复点击页面上的按钮。</li><li>网络异常，由于网络原因导致在一定时间内末返回调用成功的信息，触发了框架层的重试机制。</li><li>页面回退后再次提交的动作。</li><li>程序上的重试机制一一对于未及时响应的请求发起重试操作。</li></ul><h3 id="数据库操作的幂等性分析" tabindex="-1"><a class="header-anchor" href="#数据库操作的幂等性分析" aria-hidden="true">#</a> 数据库操作的幂等性分析</h3><p>数据库的上层业务操作分为 CRUD（即新增、读取、更新、删除4个动作）。</p><p>新增：如果自增主键唯一，，则数据库中会生成多条相同记录，不具备幂等性，如：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">INSERT</span> <span class="token keyword">into</span> <span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> balance<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&#39;test&#39;</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>读取：无论请求多少次，读取的结果都是一样的，所以读取是天然幂等的，如：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">Select</span> name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> balance <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>更新：条件语句中带有计算型的更新是非幂等的；反之，则是天然幂等的，如：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 非幂等</span>
<span class="token keyword">UPDATE</span> <span class="token keyword">user</span> <span class="token keyword">SET</span> balance <span class="token operator">=</span> balance <span class="token operator">+</span> <span class="token number">10</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment"># 幂等</span>
<span class="token keyword">UPDATE</span> <span class="token keyword">user</span> <span class="token keyword">SET</span> balance <span class="token operator">=</span> <span class="token number">200</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>删除：无论删除多少次，结果都是一样的，所以删除动作是天然幂等的，如：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span>；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以看出，读取和删除是天然幂等的，无论执行多少次请求，最终的结果都是一样的。从这里很容易能联想到 RESTful规范中的 HTTP 请求方法：POST(C)、GET (R)、PUT(U)、DELETE (D)。</p><h2 id="如何保证接口的幂等性" tabindex="-1"><a class="header-anchor" href="#如何保证接口的幂等性" aria-hidden="true">#</a> 如何保证接口的幂等性</h2><p>保证接口的幂等性通常有以下几种方式：</p><ul><li>唯一标识符：使用唯一标识符来标识每个请求，例如使用 UUID 或者生成的唯一 ID。</li><li>版本号：在请求中包含版本号，以确保相同的请求在不同的版本下也具有相同的结果。</li><li>检查状态：在进行更新操作前，先检查资源的状态，以确保只有在特定条件下才进行更新。</li><li>重试机制：在请求失败时，可以使用重试机制来确保请求最终成功。</li><li>幂等性标识符：在请求中包含幂等性标识符，以确保相同的请求只会被处理一次，而重复请求会被忽略。</li><li>事务控制：使用事务控制来确保相同的请求只会被处理一次，而重复请求会被忽略。</li><li>分布式锁：在分布式的场景下，使用分布式锁来阻止重复请求。</li></ul><p>下面采用两种方式说明如何防止前面用户重复提交的异常情况。</p><h3 id="利用全局唯一-id-防止重复提交" tabindex="-1"><a class="header-anchor" href="#利用全局唯一-id-防止重复提交" aria-hidden="true">#</a> 利用全局唯一 ID 防止重复提交</h3><p>在向数据库新增一条记录时，有时会出现错误信息 “result in duplicate entry tor key primary”，原因是插入了相同 ID的信息。</p><p>利用数据库的主键唯一特性，可以解决重复提交问题：对于相同 ID 的信息，数据库会抛出异常这样新增数据的请求会失败。现在已经知道方案了，那么这个 ID 该如何和系统进行绑定呢？下面来看一下具体的落地流程。</p><ol><li>搭建一个生成全局唯一 ID 的服务。建议加入一些业务信息到该服务中，例如，在生成的订单 ID 中可以包含业务信息中的订单元素（如“OD”2021122620005600001）。该全局唯一 ID 服务可以参考雪花算法 SnowFlow 进行搭建。</li><li>在订单确定页面中，调用全局唯一 ID 服务生成订单号。</li><li>在提交订单时带上订单号，请求到达订单系统的下单接口。</li><li>将数据库订单表 ID 和订单号进行映射，将订单号作为订单表的 ID。</li><li>订单系统在创建订单信息时，订单号使用前端传过来的订单号，然后直接将该订单信息插入订单库中。</li><li>如票订单写入成功，则是第一次提交，返回下单成动：如果很 ID 许突信息，则是重复提交，在订单表中只保留之前的记录，不会写入相同的新记录。</li></ol><blockquote><p>在报“订单重复提交” 错误时，不要向容户端抛出错误信息，因为重复提交的订单不一定全部失败。如果给用户展示错误，则用户可能还会提交订单，这会使得用户体验不是很好。可以直接向用户展示下单成功。</p></blockquote><h3 id="利用-token-redis-机制防止重复提交" tabindex="-1"><a class="header-anchor" href="#利用-token-redis-机制防止重复提交" aria-hidden="true">#</a> 利用 Token + Redis 机制防止重复提交</h3><p>再来看看另一个常用的保证幂等性的方案一使用 Token + Redis 机制防止重复提交。下面依然以订单系统的下单模块来讲解。</p><ol><li>订单系统提供一个发放 Token 的接口。这个 Token 是一个防重令牌，即一串唯一字符串 (可以使用 UUID 算法生成）。</li><li>在订单确认页”中调用获取 Token 的接口，该接口向订单确认页返回 Token，同时将此 Token 写入 Redis 缓存中，并依据实际业务对其设置一定的有效期。</li><li>用户在订单确认页中点击 “提交订单”按钮时，将第 2 步获取的 Token 以参数或者请求头的形式封装进订单信息中，然后请求订单系统的下单接口。</li><li>下单接口在收到提交下单的请求后，首先判断在 Redis 中是否存在当前传入的 Token。</li><li>利用数据库的主键唯一特性和 Token 机制来避免重复提交，是一种比较常用的接口幂等性方案。对于重复提交的场景，需要依据业务进行分析，分析当前场景是否具备幂等性，如果不具有幕等性，则需要进行幂等性设计。</li></ol>`,33);function c(r,d){const a=i("WaterMark");return s(),e("div",null,[t,l(a)])}const k=n(o,[["render",c],["__file","幂等性设计——保证数据的一致性.html.vue"]]);export{k as default};
